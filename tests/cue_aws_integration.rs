use async_trait::async_trait;
use cuenv::command_executor::CommandExecutor;
use cuenv::errors::{Error, Result};
use cuenv::secrets::{CommandResolver, SecretManager};
use cuenv::types::{CommandArguments, EnvironmentVariables};
use std::collections::HashMap;
use std::fs;
use std::process::Output;
use tempfile::TempDir;

// Helper function to create ExitStatus
fn exit_status_from_code(code: i32) -> std::process::ExitStatus {
    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        std::process::ExitStatus::from_raw(code)
    }
    #[cfg(windows)]
    {
        use std::os::windows::process::ExitStatusExt;
        std::process::ExitStatus::from_raw(code as u32)
    }
}

/// Test executor that simulates AWS CLI responses
struct AwsTestExecutor;

#[async_trait]
impl CommandExecutor for AwsTestExecutor {
    async fn execute(&self, cmd: &str, args: &CommandArguments) -> Result<Output> {
        let args_slice = args.as_slice();
        if cmd == "aws"
            && args_slice.len() >= 8
            && args_slice[0] == "secretsmanager"
            && args_slice[1] == "get-secret-value"
        {
            // Extract secret ID and version stage
            let mut secret_id = "";
            let mut version_stage = "";
            
            for i in 0..args_slice.len() {
                if args_slice[i] == "--secret-id" && i + 1 < args_slice.len() {
                    secret_id = &args_slice[i + 1];
                } else if args_slice[i] == "--version-stage" && i + 1 < args_slice.len() {
                    version_stage = &args_slice[i + 1];
                }
            }

            match (secret_id, version_stage) {
                ("my-database-password", "AWSCURRENT") => Ok(Output {
                    status: exit_status_from_code(0),
                    stdout: b"super-secret-db-password".to_vec(),
                    stderr: Vec::new(),
                }),
                ("my-api-key", "AWSCURRENT") => Ok(Output {
                    status: exit_status_from_code(0),
                    stdout: b"test-api-key-123".to_vec(),
                    stderr: Vec::new(),
                }),
                ("my-versioned-secret", "v2") => Ok(Output {
                    status: exit_status_from_code(0),
                    stdout: b"version-2-secret".to_vec(),
                    stderr: Vec::new(),
                }),
                _ => Ok(Output {
                    status: exit_status_from_code(1),
                    stdout: Vec::new(),
                    stderr: format!("ResourceNotFoundException: Secrets Manager can't find the specified secret \"{secret_id}\"\n").into_bytes(),
                }),
            }
        } else if cmd == "echo" {
            // Support echo command for testing
            Ok(Output {
                status: exit_status_from_code(0),
                stdout: args_slice.join(" ").into_bytes(),
                stderr: Vec::new(),
            })
        } else {
            Err(Error::command_execution(
                cmd,
                args.as_vec(),
                format!("command {cmd} not found"),
                Some(127),
            ))
        }
    }
}

#[tokio::test]
async fn test_aws_secrets_manager_integration() {
    let test_dir = TempDir::new().unwrap();
    let cue_path = test_dir.path().join("test.cue");

    // Write test CUE file with AWS Secrets Manager reference
    let cue_content = r#"
package cuenv

import "example.com/cuenv"

env: TEST_ENV: {
    variables: {
        DB_PASSWORD: cuenv.#AwsSecretsManager & {
            secret_id: "my-database-password"
        }
        API_KEY: cuenv.#AwsSecretsManager & {
            secret_id: "my-api-key"
        }
        NORMAL_VAR: "plain-value"
    }
}
"#;

    fs::write(&cue_path, cue_content).unwrap();

    // Initialize SecretManager with AWS test executor
    let secret_manager = SecretManager::with_resolver(Box::new(CommandResolver::with_executor(
        10,
        Box::new(AwsTestExecutor),
    )));

    // Create test environment variables
    let mut env_vars = EnvironmentVariables::new();
    
    // These references would be generated by CUE evaluation in real usage
    env_vars.insert(
        "DB_PASSWORD".to_string(),
        r#"cuenv-resolver://{"cmd":"aws","args":["secretsmanager","get-secret-value","--secret-id","my-database-password","--version-stage","AWSCURRENT","--query","SecretString","--output","text"]}"#.to_string(),
    );
    env_vars.insert(
        "API_KEY".to_string(),
        r#"cuenv-resolver://{"cmd":"aws","args":["secretsmanager","get-secret-value","--secret-id","my-api-key","--version-stage","AWSCURRENT","--query","SecretString","--output","text"]}"#.to_string(),
    );
    env_vars.insert("NORMAL_VAR".to_string(), "plain-value".to_string());

    // Resolve secrets
    let resolved = secret_manager.resolve_secrets(env_vars).await.unwrap();

    // Verify results
    assert_eq!(resolved.env_vars.len(), 3);
    assert_eq!(
        resolved.env_vars.get("DB_PASSWORD").unwrap(),
        "super-secret-db-password"
    );
    assert_eq!(
        resolved.env_vars.get("API_KEY").unwrap(),
        "test-api-key-123"
    );
    assert_eq!(resolved.env_vars.get("NORMAL_VAR").unwrap(), "plain-value");

    // Verify secret values were tracked
    assert_eq!(resolved.secret_values.len(), 2);
    assert!(resolved.secret_values.contains("super-secret-db-password"));
    assert!(resolved.secret_values.contains("test-api-key-123"));
}

#[tokio::test]
async fn test_aws_secrets_manager_with_version() {
    let secret_manager = SecretManager::with_resolver(Box::new(CommandResolver::with_executor(
        10,
        Box::new(AwsTestExecutor),
    )));

    let mut env_vars = EnvironmentVariables::new();
    
    // Test with specific version stage
    env_vars.insert(
        "VERSIONED_SECRET".to_string(),
        r#"cuenv-resolver://{"cmd":"aws","args":["secretsmanager","get-secret-value","--secret-id","my-versioned-secret","--version-stage","v2","--query","SecretString","--output","text"]}"#.to_string(),
    );

    let resolved = secret_manager.resolve_secrets(env_vars).await.unwrap();

    assert_eq!(
        resolved.env_vars.get("VERSIONED_SECRET").unwrap(),
        "version-2-secret"
    );
}

#[tokio::test]
async fn test_aws_secrets_manager_error_handling() {
    let secret_manager = SecretManager::with_resolver(Box::new(CommandResolver::with_executor(
        10,
        Box::new(AwsTestExecutor),
    )));

    let mut env_vars = EnvironmentVariables::new();
    
    // Test with non-existent secret
    env_vars.insert(
        "MISSING_SECRET".to_string(),
        r#"cuenv-resolver://{"cmd":"aws","args":["secretsmanager","get-secret-value","--secret-id","non-existent-secret","--version-stage","AWSCURRENT","--query","SecretString","--output","text"]}"#.to_string(),
    );
    env_vars.insert("NORMAL_VAR".to_string(), "plain-value".to_string());

    let resolved = secret_manager.resolve_secrets(env_vars).await.unwrap();

    // The missing secret should retain its original value
    assert_eq!(resolved.env_vars.len(), 2);
    assert!(resolved.env_vars.get("MISSING_SECRET").unwrap().starts_with("cuenv-resolver://"));
    assert_eq!(resolved.env_vars.get("NORMAL_VAR").unwrap(), "plain-value");
    
    // Only successful secrets should be in secret_values
    assert_eq!(resolved.secret_values.len(), 0);
}

#[tokio::test]
async fn test_multiple_aws_secrets_concurrent() {
    let secret_manager = SecretManager::with_resolver(Box::new(CommandResolver::with_executor(
        10,
        Box::new(AwsTestExecutor),
    )));

    let mut env_vars = EnvironmentVariables::new();
    
    // Add multiple secrets
    for i in 0..5 {
        env_vars.insert(
            format!("SECRET_{i}"),
            r#"cuenv-resolver://{"cmd":"aws","args":["secretsmanager","get-secret-value","--secret-id","my-database-password","--version-stage","AWSCURRENT","--query","SecretString","--output","text"]}"#.to_string(),
        );
    }

    let resolved = secret_manager.resolve_secrets(env_vars).await.unwrap();

    // All secrets should resolve to the same value
    assert_eq!(resolved.env_vars.len(), 5);
    for i in 0..5 {
        assert_eq!(
            resolved.env_vars.get(&format!("SECRET_{i}")).unwrap(),
            "super-secret-db-password"
        );
    }
    
    // secret_values should deduplicate identical values
    assert_eq!(resolved.secret_values.len(), 1);
    assert!(resolved.secret_values.contains("super-secret-db-password"));
}